<#
.SYNOPSIS
  使用 PowerShell 的正则表达式解析 .rb 文件中的 describe 块，并同时提取内含的 it { ... } 和 its('...') { ... } 语句。

.DESCRIPTION
  1. 整体思路：先用第一层正则捕获 describe 块，再对每个块用第二层正则捕获其下的 it 与 its 语句。
  2. 注意，如果你的 it { ... } / its { ... } 是多行或更复杂的书写方式，需要额外处理。

.EXAMPLE
  PS C:\> .\ParseItAndIts.ps1 -Path .\controls.rb
#>

param(
    [Parameter(Mandatory=$true, HelpMessage="请指定包含 InSpec 控制文件的 .rb 文件路径")]
    [string]$Path
)

if (!(Test-Path $Path)) {
    Write-Host "文件 $Path 不存在。请确认路径正确。"
    return
}

# 1. 读取整个文件为一个字符串，-Raw 可保留换行
$fileContent = Get-Content -Path $Path -Raw

# 2. 匹配所有 describe ... do ... end 块
#    (?ms):
#       - (?m) 多行模式，让 ^ $ 匹配行首和行尾
#       - (?s) 单行模式，让 '.' 可匹配换行
#    正则分组:
#       - (?<resource>) 捕获 describe 后面的资源字符串
#       - (?<body>) 捕获 describe ... do ... 与 end 之间的全部内容
$describePattern = '(?ms)^\s*describe\s+(?<resource>.*?)\s+do\s*(?<body>.*?)^\s*end\s*'
$describeMatches = [regex]::Matches($fileContent, $describePattern)

if ($describeMatches.Count -eq 0) {
    Write-Host "未找到任何 describe 块。"
    return
}

# 3. 分别加两个正则，专门匹配 it 与 its
# 
#   it { ... }
#     - ^\s*it\s*\{\s*(?<itBody>[^}]*)\}
#       捕获大括号内的语句, 简化处理单行情况
#
#   its('xxx') { ... }
#     - ^\s*its\s*\(\s*["']?(?<itsField>[^"'\)]+)["']?\)\s*\{\s*(?<itsBody>[^}]*)\}
#       捕获 its(...) 中的字段以及大括号内的语句
#
$itPattern  = '(?m)^\s*it\s*\{\s*(?<itBody>[^}]*)\}'
$itsPattern = '(?m)^\s*its\s*\(\s*["'']?(?<itsField>[^"'\)]+)["'']?\)\s*\{\s*(?<itsBody>[^}]*)\}'

# 4. 解析并输出结果
$allDescribes = @()

foreach ($descMatch in $describeMatches) {
    $resourceName = $descMatch.Groups['resource'].Value.Trim()
    $blockContent = $descMatch.Groups['body'].Value

    # 匹配所有 it { ... } 语句
    $foundIts  = [regex]::Matches($blockContent, $itPattern)
    # 匹配所有 its(...) { ... } 语句
    $foundItsS = [regex]::Matches($blockContent, $itsPattern)

    # 组合到对象中
    $describeObject = [PSCustomObject]@{
        ResourceName = $resourceName
        ItStatements = @()  # 存放 it 的内容
        ItsStatements= @()  # 存放 its('xxx') 的内容
    }

    foreach ($m in $foundIts) {
        $itBody = $m.Groups['itBody'].Value.Trim()
        $describeObject.ItStatements += $itBody
    }

    foreach ($m in $foundItsS) {
        $field = $m.Groups['itsField'].Value.Trim()
        $body  = $m.Groups['itsBody'].Value.Trim()
        $describeObject.ItsStatements += ,([PSCustomObject]@{
            Field = $field
            Body  = $body
        })
    }

    $allDescribes += $describeObject
}

# 5. 输出
$allDescribes
