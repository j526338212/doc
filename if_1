#  Step 1: Sample Ruby/Inspec code
#  (In real usage, read this from a file or another source)
  $code = @'
  control "example-control" do
    
    # Here's the multiline description in double quotes
    description "Here is a multiline
      description text with
      if false
      some more lines
    "

    if false
      puts "this is if-block"
      if nested_condition
        # This is a nested if block, example – to be ignored
      end
    elsif nil
      puts "this is elsif-block"
    else
      puts "this is else-block"
    end

    description "Another description that might
    contain else or end or something"
  end
'@

#  Step 2: Remove multiline description in double quotes
#  Explanation:
#    - (?s) makes '.' match newlines
#    - description\s*"  matches the keyword 'description' plus any whitespace, then a double quote
#    - .*? (lazy) matches as few characters as possible until the next double quote
#    - "  matches the closing quote
#  Depending on your scenario, you might need a more sophisticated pattern if descriptions contain nested quotes.
  $pattern = '(?s)description\s*".*?"'

#  Use [regex]::Matches to find all matches
  $matches = [regex]::Matches($code, $pattern)

#  Replace each match with an empty string
  foreach ($m in $matches) {
    $code = $code.Replace($m.Value, "")
  }

#  Step 3: Split code by lines
  $lines = $code -split "`r?`n"

#  Step 4: Define variables for capturing conditions/blocks
  $ifCondition    = ""
  $ifBlock        = ""
  $elsifCondition = ""
  $elsifBlock     = ""
  $elseBlock      = ""

#  We only parse the first-level if/elsif/else/end.
#  If we see a nested if, skip until the matching end.
  $currentLevel = 0
  $skipNested   = $false
  $currentBlock = $null  # can be 'if', 'elsif', or 'else'

#  Step 5: Parse the stripped code
  foreach ($line in $lines) {
    $trimLine = $line.Trim()

    # If currently skipping a nested if
    if ($skipNested) {
      if ($trimLine -match '^end\s*$') {
        $currentLevel--
        if ($currentLevel -eq 0) {
          $skipNested = $false
        }
      }
      else {
        # If another 'if' is encountered, it’s another level of nesting
        if ($trimLine -match '^if\s+.*') {
          $currentLevel++
        }
      }
      continue
    }

    switch -Regex ($trimLine) {

      '^if\s+(.*)' {
        # If we haven't entered any if structure yet, this is the first-level if
        if (-not $currentBlock) {
          $ifCondition += $Matches[1]
          $currentBlock = 'if'
        }
        else {
          # Seeing another 'if' within an existing block => nested, skip
          $skipNested   = $true
          $currentLevel = 1
        }
      }

      '^elsif\s+(.*)' {
        # Entering elsif
        if ($currentBlock -eq 'if' -or $currentBlock -eq 'elsif') {
          $elsifCondition += $Matches[1]
          $currentBlock = 'elsif'
        }
      }

      '^else\s*$' {
        # Entering else
        if ($currentBlock -in @('if','elsif')) {
          $currentBlock = 'else'
        }
      }

      '^end\s*$' {
        # End if block
        if ($currentBlock) {
          $currentBlock = $null
        }
      }

      default {
        # It's the body of the if/elsif/else
        switch ($currentBlock) {
          'if'    { $ifBlock    += ($line + "`n") }
          'elsif' { $elsifBlock += ($line + "`n") }
          'else'  { $elseBlock  += ($line + "`n") }
        }
      }
    }
  }

#  Step 6: Output results
  Write-Host "----- IF condition -----"
  Write-Host $ifCondition

  Write-Host "----- IF block content -----"
  Write-Host $ifBlock

  Write-Host "----- ELSIF condition -----"
  Write-
